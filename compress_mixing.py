# -*- coding: utf-8 -*-
"""Untitled31.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ui-eOftvr7EfE_HKON0j6CLQJAn62Pqm
"""

!pip install g711 numpy scipy



# -*- coding: utf-8 -*-
"""
Chương trình thực hiện Nén/Giải nén G.711 A-law cho Task 3
Sử dụng Lookup Table chuẩn, không dùng thư viện g711.
"""

import numpy as np
from scipy.io import wavfile
import math
import traceback # Để in chi tiết lỗi

# ================================================================
# === Bảng tra và Hàm G.711 A-law chuẩn (Dựa trên mã C chuẩn) ===
# ================================================================

# Bảng tra giải mã A-law (256 giá trị 8-bit A-law -> 16-bit linear)
_alaw_decode_table = np.array([
    -5504, -5248, -6016, -5760, -4480, -4224, -4992, -4736, -7552, -7296, -8064, -7808, -6528, -6272, -7040, -6784,
    -2752, -2624, -3008, -2880, -2240, -2112, -2496, -2368, -3776, -3648, -4032, -3904, -3264, -3136, -3520, -3392,
    -11008,-10496,-12032,-11520, -8960, -8448, -9984, -9472,-15104,-14592,-16128,-15616,-13056,-12544,-14080,-13568,
    -5504, -5248, -6016, -5760, -4480, -4224, -4992, -4736, -7552, -7296, -8064, -7808, -6528, -6272, -7040, -6784,
    -1376, -1312, -1504, -1440, -1120, -1056, -1248, -1184, -1888, -1824, -2016, -1952, -1632, -1568, -1760, -1696,
    -688,  -656,  -752,  -720,  -560,  -528,  -624,  -592,  -944,  -912, -1008,  -976,  -816,  -784,  -880,  -848,
    -2752, -2624, -3008, -2880, -2240, -2112, -2496, -2368, -3776, -3648, -4032, -3904, -3264, -3136, -3520, -3392,
    -1376, -1312, -1504, -1440, -1120, -1056, -1248, -1184, -1888, -1824, -2016, -1952, -1632, -1568, -1760, -1696,
     5504,  5248,  6016,  5760,  4480,  4224,  4992,  4736,  7552,  7296,  8064,  7808,  6528,  6272,  7040,  6784,
     2752,  2624,  3008,  2880,  2240,  2112,  2496,  2368,  3776,  3648,  4032,  3904,  3264,  3136,  3520,  3392,
    11008, 10496, 12032, 11520,  8960,  8448,  9984,  9472, 15104, 14592, 16128, 15616, 13056, 12544, 14080, 13568,
     5504,  5248,  6016,  5760,  4480,  4224,  4992,  4736,  7552,  7296,  8064,  7808,  6528,  6272,  7040,  6784,
     1376,  1312,  1504,  1440,  1120,  1056,  1248,  1184,  1888,  1824,  2016,  1952,  1632,  1568,  1760,  1696,
      688,   656,   752,   720,   560,   528,   624,   592,   944,   912,  1008,   976,   816,   784,   880,   848,
     2752,  2624,  3008,  2880,  2240,  2112,  2496,  2368,  3776,  3648,  4032,  3904,  3264,  3136,  3520,  3392,
     1376,  1312,  1504,  1440,  1120,  1056,  1248,  1184,  1888,  1824,  2016,  1952,  1632,  1568,  1760,  1696
], dtype=np.int16)

# Hàm giải mã A-law sử dụng bảng tra
def decode_alaw_lut(alaw_byte_unsigned):
    # Chỉ cần tra bảng
    return _alaw_decode_table[alaw_byte_unsigned]

# Hàm mã hóa A-law (chuẩn ITU-T G.711)
_A_LAW_MAX = 0x7fff # Giá trị lớn nhất cho 16-bit signed
_A_QUANT_MASK = 0xf # Mask cho 4 bit cuối (mantissa)
_A_SEG_SHIFT = 4   # Vị trí bit phân đoạn
_A_SEG_MASK = 0x70  # Mask cho 3 bit phân đoạn
_A_SIGN_BIT = 0x80  # Bit dấu

def encode_alaw_lut(sample_16bit):
    # Chuẩn hóa giá trị sample_16bit về khoảng 13 bit hiệu dụng
    # (Trong nhiều implementation C, giá trị đầu vào thường là 12 hoặc 13 bit)
    # Chúng ta có thể dịch phải 3 bit để đưa về gần vùng 13 bit
    pcm_val = sample_16bit >> 3

    # Lấy dấu và giá trị tuyệt đối
    if pcm_val >= 0:
        mask = 0xD5 # 11010101 (A-law positive samples)
    else:
        mask = 0x55 # 01010101 (A-law negative samples)
        pcm_val = -pcm_val - 1 # Lấy giá trị tuyệt đối (và hiệu chỉnh)

    # Giới hạn giá trị (nếu cần, mặc dù dịch bit thường đã đủ)
    # pcm_val = min(pcm_val, _A_LAW_MAX >> 3)

    # Tìm đoạn (segment)
    if pcm_val < 32: # Đoạn 0
        seg = 0
        aval = pcm_val << 4
    elif pcm_val < 64: # Đoạn 1
        seg = 1
        aval = (pcm_val << 3) + 0x100
    elif pcm_val < 128: # Đoạn 2
        seg = 2
        aval = (pcm_val << 2) + 0x300
    elif pcm_val < 256: # Đoạn 3
        seg = 3
        aval = (pcm_val << 1) + 0x700
    elif pcm_val < 512: # Đoạn 4
        seg = 4
        aval = pcm_val + 0xF00
    elif pcm_val < 1024: # Đoạn 5
        seg = 5
        aval = (pcm_val >> 1) + 0x1F00
    elif pcm_val < 2048: # Đoạn 6
        seg = 6
        aval = (pcm_val >> 2) + 0x3F00
    elif pcm_val < 4096: # Đoạn 7
        seg = 7
        aval = (pcm_val >> 3) + 0x7F00
    else: # Lớn hơn hoặc bằng 4096 -> gán giá trị lớn nhất của đoạn 7
        seg = 7
        aval = 0xFF00

    # Kết hợp đoạn và phần định lượng trong đoạn
    if seg < 8:
      aval = (seg << _A_SEG_SHIFT) | ((aval >> 8) & _A_QUANT_MASK)

    # XOR với mask để có byte A-law cuối cùng
    return np.uint8(aval ^ mask)

# ================================================================
# ================== KẾT THÚC PHẦN HÀM G.711 ====================
# ================================================================

# --- Chương trình chính ---
input_wav_file = 'original_audio_8khz.wav' # File đã resample!
use_alaw = True # Bây giờ chỉ hỗ trợ A-law với code này

# --- Đặt tên file đầu ra dựa trên cấu hình ---
if use_alaw:
    compressed_raw_file = 'compressed_audio.g711a' # File nén đầu ra (A-law)
    codec_name = "A-law (LUT)"
else:
    # Code µ-law chưa được thêm vào đây
    print("!!! Lỗi: Code này hiện chỉ hỗ trợ A-law !!!")
    exit()

decoded_wav_file = f'decoded_g711{"a" if use_alaw else "u"}_audio.wav' # File giải nén

# --- Bắt đầu xử lý ---
print(f"Chuẩn bị xử lý file: {input_wav_file} bằng G.711 {codec_name}")

try:
    # 1. Đọc file WAV đầu vào (8kHz, 16-bit)
    print(f"\nBước 1: Đọc file {input_wav_file}...")
    fs, audio_data = wavfile.read(input_wav_file)
    print(f"   Đọc thành công: Fs={fs}, Dtype={audio_data.dtype}, Samples={len(audio_data)}")

    # Kiểm tra cơ bản
    if fs != 8000:
        print("   *** Cảnh báo: Tần số lấy mẫu không phải 8000 Hz! ***")
    if audio_data.dtype != np.int16:
        print(f"   *** Cảnh báo: Kiểu dữ liệu là {audio_data.dtype}, không phải int16. Đang cố gắng chuyển đổi... ***")
        if np.issubdtype(audio_data.dtype, np.floating):
             audio_data = (audio_data * 32767).astype(np.int16)
        else:
             audio_data = audio_data.astype(np.int16)
        print(f"   Đã chuyển đổi kiểu dữ liệu sang: {audio_data.dtype}")

    # Đảm bảo mono
    if audio_data.ndim > 1:
        print("   Tín hiệu là stereo, đang lấy kênh trái...")
        audio_data = audio_data[:, 0]

    # 2. Nén dữ liệu bằng hàm tự viết với LUT
    print(f"\nBước 2: Bắt đầu nén G.711 {codec_name}...")
    compressed_data_list = [] # Dùng list để append hiệu quả hơn
    for sample in audio_data:
        compressed_data_list.append(encode_alaw_lut(sample)) # Gọi hàm encode mới

    # Chuyển list thành mảng NumPy uint8
    compressed_data_np = np.array(compressed_data_list, dtype=np.uint8)
    print(f"   Nén hoàn tất. Số byte nén: {len(compressed_data_np)}")

    # 3. Lưu file nén thô (raw binary)
    print(f"\nBước 3: Lưu file nén vào {compressed_raw_file}...")
    compressed_data_np.tofile(compressed_raw_file) # Lưu mảng NumPy ra file
    print(f"   Đã lưu file nén.")

    # 4. Giải nén dữ liệu bằng hàm tự viết với LUT
    print(f"\nBước 4: Bắt đầu giải nén G.711 {codec_name}...")
    decoded_data_list = []
    for compressed_sample in compressed_data_np:
        decoded_data_list.append(decode_alaw_lut(compressed_sample)) # Gọi hàm decode mới

    # Chuyển list thành mảng NumPy int16
    decoded_data_np = np.array(decoded_data_list, dtype=np.int16)
    print(f"   Giải nén hoàn tất. Số mẫu giải nén: {len(decoded_data_np)}")

    # 5. Lưu file WAV đã giải nén
    print(f"\nBước 5: Lưu file giải nén vào {decoded_wav_file}...")
    wavfile.write(decoded_wav_file, fs, decoded_data_np)
    print(f"   Đã lưu file giải nén.")
    print(f"\n=> HOÀN THÀNH! File '{decoded_wav_file}' dùng để nghe thử và tính PSNR ở Bước 4.")

# Xử lý lỗi nếu có
except FileNotFoundError:
    print(f"\n!!! LỖI: Không tìm thấy file {input_wav_file}. Đảm bảo bạn đã chạy resample thành công và file nằm đúng chỗ. !!!")
except Exception as e:
    print(f"\n!!! Đã xảy ra lỗi trong quá trình xử lý: {e} !!!")
    print("\n--- Chi tiết lỗi (Traceback) ---")
    traceback.print_exc() # In chi tiết lỗi để debug
    print("--- Kết thúc chi tiết lỗi ---")

!apt-get update && apt-get install -y ffmpeg

!ffmpeg -i original_audio_8khz.wav -b:a 64k compressed_audio.mp3

!ffmpeg -i compressed_audio.mp3 decoded_mp3_audio.wav

import numpy as np
from scipy.io import wavfile
import math
import traceback

def calculate_psnr(original, compressed):
    """Tính PSNR giữa hai tín hiệu âm thanh."""
    # Chuyển sang float64 để tính toán chính xác
    original = original.astype(np.float64)
    compressed = compressed.astype(np.float64)

    # Tính MSE (Mean Squared Error)
    mse = np.mean((original - compressed) ** 2)

    if mse == 0:
        # Hoàn hảo, không có lỗi (PSNR là vô cùng)
        return float('inf')

    # Giá trị mẫu tối đa (cho 16-bit signed)
    max_pixel = 32767.0

    # Tính PSNR (theo dB)
    psnr = 10 * math.log10(max_pixel**2 / mse)
    return psnr

# --- Tên File (Đảm bảo các file này tồn tại trong Colab sau các bước trước) ---
original_file = 'original_audio_8khz.wav'
# !! Chỉnh sửa dòng dưới cho đúng với file G711 bạn đã tạo (a-law hoặc u-law) !!
decoded_g711_file = 'decoded_g711a_audio.wav' # HOẶC 'decoded_g711u_audio.wav'
decoded_mp3_file = 'decoded_mp3_audio.wav'   # File tạo từ ffmpeg ở Bước 4.1

print("Bắt đầu tính toán PSNR...")

try:
    # --- Đọc các file WAV ---
    print(f"Đọc file gốc: {original_file}")
    fs_orig, data_orig = wavfile.read(original_file)
    if data_orig.ndim > 1: data_orig = data_orig[:, 0] # Đảm bảo mono
    data_orig = data_orig.astype(np.float64) # Chuyển sang float

    print(f"Đọc file giải nén G.711: {decoded_g711_file}")
    fs_g711, data_g711 = wavfile.read(decoded_g711_file)
    if data_g711.ndim > 1: data_g711 = data_g711[:, 0]
    data_g711 = data_g711.astype(np.float64)

    print(f"Đọc file giải nén MP3: {decoded_mp3_file}")
    fs_mp3, data_mp3 = wavfile.read(decoded_mp3_file)
    if data_mp3.ndim > 1: data_mp3 = data_mp3[:, 0]
    data_mp3 = data_mp3.astype(np.float64)

    # --- Kiểm tra Sample Rate ---
    if not (fs_orig == fs_g711 == fs_mp3 == 8000):
        print("!!! CẢNH BÁO: Tần số lấy mẫu không khớp hoặc không phải 8000 Hz! Kết quả PSNR có thể không chính xác. !!!")
        print(f"   Fs gốc: {fs_orig}, Fs G711: {fs_g711}, Fs MP3: {fs_mp3}")
        # Nếu không khớp, bạn cần resample file MP3 về 8000Hz trước khi đọc

    # --- Đảm bảo cùng độ dài (quan trọng!) ---
    # Cắt các tín hiệu về độ dài ngắn nhất để so sánh từng mẫu
    min_len = min(len(data_orig), len(data_g711), len(data_mp3))
    data_orig = data_orig[:min_len]
    data_g711 = data_g711[:min_len]
    data_mp3 = data_mp3[:min_len]
    print(f"   Đã cắt các tín hiệu về cùng độ dài: {min_len} mẫu")

    # --- Tính toán PSNR ---
    print("\nĐang tính PSNR...")
    psnr_g711 = calculate_psnr(data_orig, data_g711)
    psnr_mp3 = calculate_psnr(data_orig, data_mp3)

    # --- In kết quả ---
    print("\n--- KẾT QUẢ PSNR ---")
    # !! Nhớ ghi rõ là A-law hay u-law !!
    print(f"PSNR giữa gốc (8kHz) và G.711 (A-law?): {psnr_g711:.2f} dB")
    print(f"PSNR giữa gốc (8kHz) và MP3 (64kbps): {psnr_mp3:.2f} dB")
    print("----------------------")
    print("\nPSNR càng cao, về mặt toán học, tín hiệu giải nén càng giống tín hiệu gốc.")
    print("Bạn cần ghi lại các giá trị này và đưa ra nhận xét so sánh trong báo cáo.")

except FileNotFoundError as e:
    print(f"\n!!! LỖI: Không tìm thấy file cần thiết: {e}. !!!")
    print("   Hãy đảm bảo bạn đã tạo thành công các file:")
    print(f"   - {original_file}")
    print(f"   - {decoded_g711_file} (từ Bước 3)")
    print(f"   - {decoded_mp3_file} (từ Bước 4.1 dùng ffmpeg)")
except Exception as e:
    print(f"\n!!! Đã xảy ra lỗi trong quá trình tính PSNR: {e} !!!")
    traceback.print_exc()

!pip install midiutil

import numpy as np
from scipy.io import wavfile
from midiutil import MIDIFile # Import thư viện vừa cài
import traceback

input_wav_file = 'original_audio_8khz.wav' # File gốc 8kHz để lấy độ dài
output_midi_file = "jazz_music.mid"      # File MIDI đầu ra

print(f"Bắt đầu tạo file MIDI: {output_midi_file}")

try:
    # Lấy độ dài file âm thanh gốc (tính bằng giây)
    fs, audio_data = wavfile.read(input_wav_file)
    if audio_data.ndim > 1: audio_data = audio_data[:, 0] # Đảm bảo mono nếu cần
    duration_seconds = len(audio_data) / fs
    print(f"   Độ dài tín hiệu gốc: {duration_seconds:.2f} giây")

    # Thông số MIDI
    track    = 0
    channel  = 0
    time     = 0    # Bắt đầu từ beat 0
    tempo    = 100  # Nhịp độ (beats per minute) - Có thể thay đổi
    volume   = 100  # Âm lượng (0-127)
    program  = 33   # Chọn nhạc cụ: 33 là Electric Bass (finger) theo chuẩn General MIDI
                    # Bạn có thể thử các số khác: 0=Piano, 26=Steel Guitar, 56=Trumpet,...

    # Tạo đối tượng MIDIFile
    MyMIDI = MIDIFile(1)  # 1 track
    MyMIDI.addTempo(track, time, tempo)
    MyMIDI.addProgramChange(track, channel, time, program)

    # --- PHẦN SÁNG TẠO: Thêm các nốt nhạc ---
    # Tính tổng số beat dựa trên độ dài và tempo
    total_beats = duration_seconds * (tempo / 60.0)
    print(f"   Tổng số beat cần tạo: {total_beats:.2f}")

    current_beat = 0
    note_duration = 1 # Ví dụ: Nốt đen (quarter note) = 1 beat

    # Ví dụ: Tạo một giai điệu bass đi bộ đơn giản (C-E-G-A) lặp lại
    # BẠN NÊN THAY ĐỔI PHẦN NÀY CHO GIỐNG "JAZZ" HƠN
    # (Thêm hợp âm, thay đổi tiết tấu, dùng các nốt đặc trưng của Jazz...)
    while current_beat < total_beats:
        pitches = [48, 52, 55, 57] # Nốt C3, E3, G3, A3 (MIDI note numbers)
        for i, pitch in enumerate(pitches):
            # Chỉ thêm nốt nếu thời gian bắt đầu của nó chưa vượt quá tổng độ dài
            if current_beat + i * note_duration < total_beats:
                MyMIDI.addNote(track, channel, pitch, current_beat + i * note_duration, note_duration, volume)
            else:
                break # Dừng thêm nốt nếu hết thời gian
        current_beat += len(pitches) * note_duration
        if current_beat >= total_beats: break # Thoát vòng lặp nếu đã đủ beat

    # Lưu file MIDI
    with open(output_midi_file, "wb") as output_file:
        MyMIDI.writeFile(output_file)
    print(f"\nĐã tạo và lưu file MIDI: {output_midi_file}")
    print("   Kiểm tra file này trong danh sách Files bên trái.")

except FileNotFoundError:
     print(f"\n!!! LỖI: Không tìm thấy file {input_wav_file}. Đảm bảo bạn đã upload file này. !!!")
except ImportError:
    print("\n!!! LỖI: Không tìm thấy thư viện midiutil. Bạn đã cài đặt chưa? (!pip install midiutil) !!!")
except Exception as e:
    print(f"\n!!! Đã xảy ra lỗi trong quá trình tạo MIDI: {e} !!!")
    traceback.print_exc()

# Đổi tên 'jazz_music.wav' nếu file bạn tải lên có tên khác
!ffmpeg -i jazz_music.wav -ar 8000 -ac 1 jazz_audio_8khz.wav

import numpy as np
from scipy.io import wavfile
import traceback

speech_file = 'original_audio_8khz.wav' # File giọng nói 8kHz
music_file = 'jazz_audio_8khz.wav'           # File nhạc nền WAV 8kHz vừa tạo và upload
output_mix_file = 'final_jazz_mix.wav'  # File kết quả cuối cùng

# --- Điều chỉnh âm lượng (QUAN TRỌNG - Cần thử nghiệm) ---
# Giá trị từ 0.0 đến 1.0 (hoặc hơn nếu muốn khuếch đại)
# Giảm gain của nhạc nền để không át giọng nói
speech_gain = 0.9  # Âm lượng giọng nói (0.0 - 1.0)
jazz_gain   = 0.3  # Âm lượng nhạc nền (0.0 - 1.0) - Thường nhỏ hơn nhiều

print(f"Bắt đầu trộn file: {speech_file} và {music_file}")

try:
    # Đọc file giọng nói
    fs1, speech_data = wavfile.read(speech_file)
    if speech_data.ndim > 1: speech_data = speech_data[:,0]
    if speech_data.dtype != np.int16: speech_data = speech_data.astype(np.int16) # Đảm bảo int16

    # Đọc file nhạc nền
    fs2, jazz_data = wavfile.read(music_file)
    if jazz_data.ndim > 1: jazz_data = jazz_data[:,0]
    if jazz_data.dtype != np.int16: jazz_data = jazz_data.astype(np.int16) # Đảm bảo int16

    # Kiểm tra Sample Rate
    if fs1 != 8000 or fs2 != 8000:
         print(f"!!! Cảnh báo: Sample Rate không phải 8000Hz (Fs1={fs1}, Fs2={fs2}). Kết quả có thể không đúng. !!!")
         # Nên dừng hoặc resample nếu cần thiết
    fs = 8000 # Giả sử Fs là 8000

    # Đảm bảo cùng độ dài (lấy độ dài ngắn nhất)
    min_len = min(len(speech_data), len(jazz_data))
    speech_data = speech_data[:min_len]
    jazz_data = jazz_data[:min_len]
    print(f"   Trộn {min_len} mẫu đầu tiên của 2 file.")

    # Trộn (cộng tín hiệu) - dùng float64 để tránh tràn số
    print(f"   Áp dụng gain: Speech={speech_gain}, Jazz={jazz_gain}")
    mixed_data_float = speech_data.astype(np.float64) * speech_gain + \
                       jazz_data.astype(np.float64) * jazz_gain

    # Chuẩn hóa để tránh clipping (vượt quá giới hạn 16-bit)
    max_abs_val = np.max(np.abs(mixed_data_float))
    if max_abs_val > 32767:
        normalization_factor = 32767 / max_abs_val
        print(f"   Tín hiệu trộn bị clip, đang chuẩn hóa với factor {normalization_factor:.3f}")
        mixed_data_float = mixed_data_float * normalization_factor
    elif max_abs_val == 0:
         print("   Cảnh báo: Tín hiệu trộn bằng 0!")

    # Chuyển về int16 để lưu file WAV
    mixed_data_int16 = mixed_data_float.astype(np.int16)

    # Lưu file kết quả
    wavfile.write(output_mix_file, fs, mixed_data_int16)
    print(f"\nĐã trộn và lưu file: {output_mix_file}")
    print("   Kiểm tra và tải file này từ danh sách Files bên trái để nghe thử.")

except FileNotFoundError as e:
    print(f"\n!!! LỖI: Không tìm thấy file cần thiết: {e}. !!!")
    print(f"   Hãy đảm bảo bạn đã tạo/upload file {speech_file} và {music_file} lên Colab.")
except Exception as e:
    print(f"\n!!! Đã xảy ra lỗi trong quá trình trộn audio: {e} !!!")
    traceback.print_exc()